<!doctype html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Awesome ClojureScript!</title>

    <link rel="stylesheet" href="dist/reset.css">
    <link rel="stylesheet" href="dist/reveal.css">
    <!-- <link rel="stylesheet" href="dist/theme/black.css"> -->
    <link rel="stylesheet" href="dist/theme/white.css">

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="plugin/highlight/monokai.css">
</head>

<body>
    <style>
        .columns2 {
            display:flex;
            align-items:center;
        }

        .columns {
            display:flex;
            align-items:center;
            justify-content: space-between;
        }

        .left-column {
            padding-right: 1rem;
        }
    </style>

    <div class="reveal">
        <div class="slides">
            <section data-markdown data-separator-notes="^Note:">
                <textarea data-template>
                    ### 2021 vs ClojureScript. Still alive?
                    Alex Bykbaiev
                    Note:
                    Меня зовут Саша, и я пишу на ClojureScript-е.
                </textarea>
            </section>
            <section data-markdown data-separator-notes="^Note:">
                <textarea data-template>
                    ### About

                    <img src="examples/assets/me.jpg" alt="me" width="250"/>

                    Alex Bykbaiev, Frontend Engineer at Hopin (before acquisition Attendify).

                    Note:
                    В данный момент я работаю в компании Hopin,
                    до этого работал в Attendify,
                    пока в августе этого года компанию не приобрели.
                </textarea>
            </section>
            <section data-markdown>
                <textarea data-template>
                    ### Agenda

                    - ClojureScript, what is it??
                    - Staff I like in ClojureScript
                    - There is always a small fly in the ointment
                    - How and why we use ClojureScript in production
                    - Discussion time!
                </textarea>
            </section>
            <section>
                <h3>ClojureScript, what is it??</h3>
                <div class="columns2">
                    <div class="left-column">
                        Clojure is a compiled, functional and dynamically typed language that targets multiple existing runtimes.
                        </br>
                        ClojureScript is a compiler for Clojure that targets JavaScript.
                    </div>
                    <img src="examples/assets/logo.png" alt="cljs logo" width="250" height="250"/>
                </div>
                <aside class="notes">
                    Clojure - компилируемый, функциональный и динамически типизированный язык программирования,
                    который может использоваться на различных платформах (даже .NET CLR). Также это современный диалект Lisp-а:
                    много скобок, философия кода как данных и мощная система макросов.

                    ClojureScript - это компилятор из Clojure в JavaScript.
                    Из-за различия целевых платформ (JVM для Clojure и JavaScript для ClojureScript) в последнем
                    используется немного переработанный диалект Clojure - в основном для типов и структур данных.
                </aside>
            </section>
            <section data-markdown>
                <textarea data-template>
                    ### Staff I like in ClojureScript
                    <img src="examples/assets/fun-parts.jpeg" alt="advantages of ClojureScript" width="400">
                </textarea>
            </section>
            <section data-markdown data-separator-notes="^Note:">
                <textarea data-template>
                    ### Management of control flow
                    <img src="examples/assets/pure.jpeg" alt="control flow in FP" width="400">

                    Note:
                    Управление порядком вычислений

                    Тут я ни в коем случае не хочу спорить с приверженцами различных парадигм программирования :)
                    Если рассмотреть аспект сложности программного обеспечения с позиции понимания кодовой базы,
                    то мне намного проще живется, зная, что у меня немутабельный стейт и куча чистых функций,
                    через которые проходит большая часть данных моего приложения.

                    Но тут все не так просто, так как Clojure в первую очередь разрабатывался как практичный
                    язык программирования. Его нельзя назвать чистым (т.е. есть место для сайд эффектов и взаимодействия с хостом,
                    тут даже Foreign Function Interface не нужен - можно запросто юзать всевозможный JS код, подключать JS либы).
                    Так что чем-то пришлось пожертвовать, и тут уже нам приходится прилагать некоторые усилия для поддержки
                    чистоты)
                </textarea>
            </section>
            <section data-markdown data-separator-notes="^Note:">
                <textarea data-template>
                    ### REPL (Read–eval–print loop)
                    <img src="examples/assets/repl.gif" alt="REPL" width="700">
                    Note:
                    Цикл "чтение - вычисление - вывод".
                    Любой код можно выполнить прямо в редакторе простой комбинацией клавиш.
                    Это упрощает изучение языка, всегда можно, не отходя от кассы, протестировать
                    какой-то стандартный метод за 0 и прочее.
                    Но еще большую пользу REPL приносит в работе: REPL сервер напрямую связан с проектом, таким
                    образом он не только может исполнять куски кода, но и использовать соответствующее состояние моего
                    приложения. Таким образом я могу посмотреть на данные из стора, вызвать какой-либо эффект и посмотреть,
                    как поменяется UI в браузере.
                </textarea>
            </section>
            <section>
                <section>
                    <h3>Collections</h3>
                    <div class="columns2">
                        <div class="left-column">
                            All collections in ClojureScript are persistent (immutability + structural sharing).
                        </div>
                        <img src="examples/assets/structural-sharing.png" alt="structural sharing" width="500">
                    </div>
                    <aside class="notes">
                        Персистентная структура данных при внесении каких-либо изменений
                        сохраняет все свои предыдущие состояния и доступ к этим состояниям.
                        Таким образом дорогостоящая иммутабельность реализована в ClojureScript
                        эффективной как по памяти так и по времени. Существует понятие structual sharing, когда
                        большая часть данных "шерится" между 2 версиями значения,
                        а пересоздается лишь маленькая часть действительно изменившихся данных.

                        Аналогично работает ImmutableJS. 
                    </aside>
                </section>
                <section>
                    <h3>List</h3>
                    <p>
                        List provides efficient access to the first elements
                        (linked list under the hood).
                    </p>
                    <pre>
                        <code class="language-clojure" data-trim data-noescape data-line-numbers="1,3,6-8">
                            (def list' '(1 2 3 4))

                            (list' 0)
                            => 1

                            (let [xs '(1 2 3)     ;; (1 2 3)
                                  ys (cons 0 xs)] ;; (0 1 2 3)
                              (identical? xs (rest ys)))
                            => true
                        </code>
                    </pre>
                    <aside class="notes">
                        Список - эффективный доступ к первому элементу, перебирание элементов, добавление элемента в начало.
                        Под капотом становится связным списком.

                        В основном, списки в ClojureScript используются для группирования символов в программы -
                        вызов функции, например, это тоже список. Для хранения данных обычно используют другие коллекции в отличии от Lisp-а,
                        где все на списках. Такое решение было принятно при разработке языка для упрощения читаемости.

                        Следует заметить, что структуру данных можно использовать как функцию от ее ключа.

                        Также тут можно посмотреть на пример structural sharing-а.
                    </aside>
                </section>
                <section>
                    <h3>Vector</h3>
                    <p>
                        Vector provides efficient index access to its elements.
                    </p>
                    <pre>
                        <code class="language-clojure" data-trim data-noescape data-line-numbers="1,3">
                            (def vec' [1 2 3 4])
                        
                            (vec' 0)
                            => 1
                        </code>
                    </pre>
                    <aside class="notes">
                        Вектор - эффективный доступ к элементу по индексу, добавление в конец, Под капотом массив.
                    </aside>
                </section>
                <section>
                    <h3>Map</h3>
                    <p>
                        Map is a collection abstraction that allow you to store key/value pairs.
                    </p>
                    <pre>
                        <code class="language-clojure" data-trim data-noescape data-line-numbers="1,3,6,9">
                            (def map' {:a 1 :b 2})

                            (get map' :a)
                            => 1

                            (map' :a)
                            => 1

                            (:a map')
                            => 1
                        </code>
                    </pre>
                    <aside class="notes">
                        Map - коллекция, которая позволяет сохранять пары ключ-значение.
                        В других языках это называют хэш-меп или словарь. Любая структура данных может использоваться
                        как ключ мапы, но зачастую используют кейворды - объекты, которые всегда равны сами себе - из-за
                        того, что они могут быть использованы в качестве функции.
                    </aside>
                </section>
                <section>
                    <h3>Set</h3>
                    <p>
                        Set stores zero or more unique items of any type and is unordered.
                    </p>
                    <pre>
                        <code class="language-clojure" data-trim data-noescape data-line-numbers="1,3,6">
                            (def set' #{1 2 3 10})
                        
                            (set' 0)
                            => nil

                            (set' 10)
                            => 10
                        </code>
                    </pre>
                    <aside class="notes">
                        Сет хранит уникальные значения любого типа. Не гарантирует сохранение последовательности.
                        Часто используется как функция-предикат (значение => значение).

                        Также в ClojureScript есть абстракция Sequence (последовательность).
                        Ее можно рассматривать как список и любой другой тип коллекции может быть приведен к последовательности.
                        Большинство внутренних функций ClojureScript работают именно с последовательностями.
                        При вызове они делают последовательности из своих аргументов и работают уже с ними.
                        Таким образом эти функции можно вызывать на любом sequable типе данных.
                        Это также позволяет опускать проверки на пустые коллекции и NIL, поскольку для них
                        будет просто создана пустая последовательность.

                        И еще одна особенность - большая часть функций возвращает ленивые последовательности, это
                        хорошо сказывается на производительности, но в некоторых местах может поставить в ступор (например,
                        оптимизации реакта могут не работать).
                    </aside>
                </section>
            </section>
            <section>
                <section>
                    <h4>Metaprogramming</h4>
                    <p>
                        Clojure is also a dialect of LISP (LISt Processing language) by design.
                        The aim was to make the language more extensible.
                    </p>
                    <p>
                        Clojurescript allows you to write code that writes code (macros).
                    </p>
                </section>
                <section>
                    <h4>Macros</h4>
                    <pre>
                        <code class="language-clojure" data-trim data-noescape data-line-numbers="1-3,5,8">
                            (defmacro infix
                                [infixed]
                                (list (second infixed) (first infixed) (last infixed)))

                            (+ 1 1)
                            => 2

                            (infix (1 + 1))
                            => 2
                        </code>
                    </pre>
                    <aside class="notes">
                        Удобны для оборачивания JS либ (мы юзаем для styled-components, например) и для упрощения больших кусков кода.
                    </aside>
                </section>
                <section data-auto-animate>
                    <h4>Threading macros</h4>
                    <p data-id="code-title">Thread-first macro</p>
                    <pre data-id="code-animation">
                        <code class="language-clojure" data-trim data-noescape data-line-numbers="1-2|6-11|17-23">
                            (def user {:first-name "Alex"
                                       :last-name  "Bykbaiev"})
                            => {:first-name "Alex"
                                :last-name "Bykbaiev"}

                            (-> user
                                (update :full-name
                                        #(str (:first-name %)
                                                " "
                                                (:last-name %)))
                                (assoc :mental-age 54))
                            => {:first-name "Alex"
                                :last-name  "Bykbaiev"
                                :full-name  "Alex Bykbaiev"
                                :mental-age 54}

                            (assoc (update user
                                           :full-name
                                           #(str (:first-name %)
                                                 " "
                                                 (:last-name %))))
                                   :mental-age
                                   54)
                        </code>
                    </pre>
                </section>
                <section>
                    <h4>Threading macros</h4>
                    <p>Thread-last macro</p>
                    <pre>
                        <code class="language-clojure" data-trim data-noescape data-line-numbers="1,3,6-9">
                            (def numbers [1 2 3 4 5 6 7 8 9 0])

                            (take 2 (filter odd? (map inc numbers)))
                            => (3 5)

                            (->> numbers
                                 (map inc)
                                 (filter odd?)
                                 (take 2))
                            => (3 5)
                        </code>
                    </pre>
                </section>
                <section>
                    <h4>Threading macros</h4>
                    <p>Thread-as macro</p>
                    <pre>
                        <code class="language-clojure" data-trim data-noescape data-line-numbers="1,3,6-10">
                            (def points {:vals [1 2 3 4 5 6 7 8 9 0]})

                            (take 2 (filter odd? (map inc (get points :vals))))
                            => (3 5)

                            (as-> points $
                                  (get $ :vals)
                                  (map inc $)
                                  (filter odd? $)
                                  (take 2 $))
                            => (3 5)
                        </code>
                    </pre>
                </section>
                <section>
                    <h4>Threading macros</h4>
                    <p>Thread-some macros</p>
                    <pre>
                        <code class="language-clojure" data-trim data-noescape data-line-numbers="1,3-5,8-10">
                            (def user {:name "Alex"})

                            (-> user
                                (get :mental-age) ;; => nil
                                (str " years"))
                            => " years"

                            (some-> user
                                    (get :mental-age)
                                    (str " years"))
                            => nil
                        </code>
                    </pre>
                </section>
                <section>
                    <h4>Threading macros</h4>
                    <p>Thread-cond macros</p>
                    <pre>
                        <code class="language-clojure" data-trim data-noescape data-line-numbers="1,3,5,7-12">
                            (def month-of-birth "Jan")

                            (def motivating-Mars? true)

                            (def equalizing-Saturn? false)

                            (cond-> []
                                    (= month-of-birth "Jan") (conj "Capricornus")
                                    (= month-of-birth "Feb") (conj "Aquarius")
                                    ;; ...
                                    motivating-Mars? (conj "You would be unstoppable as the moon forms an energetic alignment to driven Mars")
                                    equalizing-Saturn? (conj "Strike a balance between visionary thinking and pragmatic planning"))
                            => ["Capricornus" "You would be unstoppable as the moon forms an energetic alignment to driven Mars"]
                        </code>
                    </pre>
                </section>
            </section>
            <section>
                <section>
                    <h4>Transducers</h4>
                    <div class="columns2">
                        <div class="left-column">
                            A transducer is a composable higher-order reducer. It takes a reducer as input, and returns another reducer.
                        </div>
                        <img src="/examples/assets/transducer.gif" alt="transducer">
                    </div>
                </section>
                <section data-auto-animate>
                    <pre data-id="code-animation">
                        <code class="language-clojure" data-trim data-noescape data-line-numbers="1,3-6|11-13,15,18,21">
                            (def xs [1 2 3 4 5 6 7 8 9 0])

                            (->> xs
                                 (map inc)
                                 (filter odd?)
                                 (take 2))
                            => (3 5)

                            ;; map = transform => reducer => reducer

                            (def tr (comp (map inc)
                                          (filter odd?)
                                          (take 2)))

                            (reduce (tr conj) [] xs)
                            => [3 5]

                            (into [] tr xs)
                            => [3 5]

                            (transduce tr conj [] xs)
                            => [3 5]
                        </code>
                    </pre>
                </section>
                <section>
                    <h4>Transducers</h4>
                    <img src="/examples/assets/transducer-from-the-box.png" alt="ClojureScript functions as transducers" width="800" />
                </section>
            </section>
            <section>
                <section>
                    <h4>Performance</h4>
                    <img src="examples/assets/compiler.png" alt="compilation flow" width="300">
                </section>
                <section>
                    <pre>
                        <code class="language-clojure" data-trim data-noescape data-line-numbers>
                            (def xs [1 2 3 4 5 6 7 8 9 0])

                            (->> xs
                                (map inc)
                                (filter odd?)
                                (take 2))
                        </code>
                    </pre>
                    <pre>
                        <code class="language-js" data-trim data-noescape data-line-numbers>
                            cljs.user.xs = new cljs.core.PersistentVector(
                                null, 10, 5, cljs.core.PersistentVector.EMPTY_NODE, [(1),(2),(3),(4),(5),(6),(7),(8),(9),(0)], null
                            );
                            cljs.core.take.call(
                                null,(2),cljs.core.filter.call(
                                    null,cljs.core.odd_QMARK_,cljs.core.map.call(
                                        null,cljs.core.inc,cljs.user.xs
                                    )
                                )
                            );
                        </code>
                    </pre>
                </section>
            </section>
            <section>
                <h4>Ecosystem</h4>
                <ul>
                    <li>Leiningen ~ package.json (dependencies + scripts)</li>
                    <li>shadow-cljs ~ webpack</li>
                    <li>Reagent/Om/Rum - React wrappers</li>
                    <li>Re-frame - Redux on steroids</li>
                </ul>
                <div class="columns">
                    <img src="examples/assets/leiningen.png" alt="Leiningen" width="200">
                    <img src="examples/assets/shadow-cljs.png" alt="shadow-cljs" width="200">
                    <img src="examples/assets/reagent.png" alt="reagent" width="200">
                    <img src="examples/assets/re-frame.png" alt="re-frame" width="200">
                </div>
            </section>
            <section>
                <h3>There is always a fly in the ointment</h3>
                <img src="examples/assets/fly-in-ointment.jpeg" alt="cons" width="300">
                <aside class="notes">
                    Поговорим о недостатках. Приходилось выдавливать их из себя, потому что вообще-то ClojureScript топовый)
                </aside>
            </section>
            <section>
                <h4>Bundle size</h4>
                <p>NEED PRODUCTION BUILD</p>
                <img src="examples/assets/bundle-size.png" alt="bundle size" width="600">
                <a style="display:block;"
                   href="https://medium.com/dailyjs/a-realworld-comparison-of-front-end-frameworks-2020-4e50655fe4c1"
                   target="_blank">
                    RealWorld Comparison 2020
                </a>
                <aside class="notes">
                    У ClojureScript есть свой runtime, понятное дело, что это добавляет к размеру бандла еще лишние килобайты.
                    Если сравнивать с JS, то это довольно заметно для маленьких проектов, но чем проект больше,
                    тем большим количеством каких-то вспомогательных библиотек он обрастает (lodash, ramda, rxjs etc.).
                    В проектах на ClojureScript библиотек зачастую меньше (язык из коробки предоставляет много возможностей).
                    Плюс к тому эффективный tree-shaking из коробки у shadow-cljs и по исследованию "RealWorld Comparison" бандл среднего
                    по размерам проекта на ClojureScript меньше бандла аналогичного проекта, но написанного на ReactJS.
                </aside>
            </section>
            <section>
                <h4>Performance</h4>
                <aside class="notes">
                    Преобразования данных из CLJS в JS и обратно довольно дорогостощие.
                    При использовании библиотек из JS это может стать проблемой.
                </aside>
            </section>
            <section>
                <h4>Memory</h4>
                <aside class="notes">
                    ClojureScript использует довольно много памяти.
                    Обычно это связано с персистентностью коллекций и ленивыми вычислениями
                    (Garbage Collector не понимает, можно ли удалять данные, которые, по факту, уже не используются).
                </aside>
            </section>
            <section>
                <h4>Dynamic type system</h4>
                <img src="examples/assets/dynamic-typing.jpeg" alt="dynamic type system" width="400">
                <aside class="notes">
                    Тут на вкус и цвет товарищей нет. Лично я от ее отсутствия не особо страдаю,
                    да и тот факт, что в рантайме все равно ничего не останется, отталкивает от нее.
                    С Elm-ом и его JSON сериалайзерами работать приятно, с TS-ом просто норм, ни больше ни меньше.
                </aside>
            </section>
            <section>
                <h4>Support</h4>
                <img src="examples/assets/8-years.png" alt="8 years to fix performance issue" width="300">
                <a style="display:block" href="https://www.clojuriststogether.org/" target="_blank">clojurists together</a>
                <aside class="notes">
                    Коммьюнити в ClojureScript несколько меньше чем в JS. Иногда можно заметить, как уходят годы на фикс бага в коре
                    или же библиотеку перестают поддерживать). Но тут все не так плохо: люди говорят, что если давно не было коммитов,
                    то, значит, все хорошо, и оно и так работает. Существует фонд поддержки разработчиков наиболее важных библиотек на Clojure.
                    Ребята проводят опросы и выясняют, какие библиотеки наиболее полезны, а потом спонсируют их дальнейшую разработку.
                    Также вcе следят за обратной совместимостью, например, текущая версия ClojureScript 1.10.879, аналогично обычно состоит
                    ситуация и для библиотек. Все продумано и стабильно)
                </aside>
            </section>
            <section>
                <h4>No popular source of knowledge</h4>
                <p>JS - please, read the documentation, there are also learnjavascript, tonns of "Learn JS in 10 mins", video courses, books, blog posts etc.</p>
                <p>ClojureScript - hmm... we have Cheatsheet, maybe some API docs, 2-3 books (it's difficult to find, but you should try!)</p>
                <aside class="notes">
                    Намного меньше учебных материалов по сравнению с более популярными языками делает ClojureScript не то чтобы
                    сложным для изучения, но всегда надо что-то искать)
                </aside>
            </section>
            <section>
                <h4>Job opportunities</h4>
                <p>It's difficult both to find a job and to hire</p>
                <img src="examples/assets/difficult-choice.png" alt="how to get a CLJS job" width="320">
                <aside class="notes">
                    На самом деле, это шутка, есть хорошие компании, в которых используется ClojureScript)
                    А отсутствие популярности вызвано отсутствием маркетинговых компаний, язык то топовый :)
                </aside>
            </section>
            <section>

            </section>
        </div>
    </div>

    <script src="dist/reveal.js"></script>
    <script src="plugin/notes/notes.js"></script>
    <script src="plugin/markdown/markdown.js"></script>
    <script src="plugin/highlight/highlight.js"></script>
    <script>
        // More info about initialization & config:
        // - https://revealjs.com/initialization/
        // - https://revealjs.com/config/
        Reveal.initialize({
            hash: true,

            // Learn about plugins: https://revealjs.com/plugins/
            plugins: [RevealMarkdown, RevealHighlight, RevealNotes]
        });
    </script>
</body>

</html>