<!doctype html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Awesome ClojureScript!</title>

    <link rel="stylesheet" href="dist/reset.css">
    <link rel="stylesheet" href="dist/reveal.css">
    <!-- <link rel="stylesheet" href="dist/theme/black.css"> -->
    <link rel="stylesheet" href="dist/theme/white.css">

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="plugin/highlight/monokai.css">
</head>

<body>
    <style>
        .columns2 {
            display:flex;
            align-items:center;
        }

        .columns {
            display:flex;
            align-items:center;
            justify-content: space-between;
        }

        .left-column {
            padding-right: 1rem;
        }

        .right-column {
            padding-left: 1rem;
        }

        .text-28 {
            font-size: 28px;
        }
    </style>

    <div class="reveal">
        <div class="slides">
            <section data-markdown data-separator-notes="^Note:">
                <textarea data-template>
                    ### 2021 vs ClojureScript. Still alive?
                    Alex Bykbaiev
                    Note:
                    Меня зовут Саша, и я пишу на ClojureScript-е.
                </textarea>
            </section>
            <section data-markdown data-separator-notes="^Note:">
                <textarea data-template>
                    ### About

                    <img src="examples/assets/me.jpg" alt="me" width="250"/>

                    Alex Bykbaiev, Frontend Engineer at Hopin.

                    Note:
                    В данный момент я работаю в компании Hopin,
                    до этого работал в Attendify,
                    пока в июле этого года компанию не приобрели.
                </textarea>
            </section>
            <section data-markdown>
                <textarea data-template>
                    ### Agenda

                    - ClojureScript, what is it??
                    - Stuff I like in ClojureScript
                    - There is always a small fly in the ointment
                    - How and why we use ClojureScript in production
                    - Some resources to learn more about ClojureScript
                    - Q&A
                </textarea>
            </section>
            <section>
                <h3>ClojureScript, what is it??</h3>
                <div class="columns2">
                    <div class="left-column">
                        Clojure is a compiled, functional and dynamically typed language that targets multiple existing runtimes.
                        </br>
                        ClojureScript is a compiler for Clojure that targets JavaScript.
                    </div>
                    <img src="examples/assets/logo.png" alt="cljs logo" width="250" height="250"/>
                </div>
                <aside class="notes">
                    Clojure - компилируемый, функциональный и динамически типизированный язык программирования,
                    который может использоваться на различных платформах (даже .NET CLR). Также это современный диалект Lisp-а:
                    много скобок, философия кода как данных и мощная система макросов.

                    ClojureScript - это компилятор из Clojure в JavaScript.
                    Из-за различия целевых платформ (JVM для Clojure и JavaScript для ClojureScript) в последнем
                    используется немного переработанный диалект Clojure - в основном для типов и структур данных.
                </aside>
            </section>
            <section data-markdown>
                <textarea data-template>
                    ### Stuff I like in ClojureScript
                    <img src="examples/assets/fun-parts.jpeg" alt="advantages of ClojureScript" width="400">
                </textarea>
            </section>
            <section data-markdown data-separator-notes="^Note:">
                <textarea data-template>
                    ### Management of control flow
                    <img src="examples/assets/pure-fn.png" alt="control flow in FP" width="550">

                    Note:
                    Управление порядком вычислений

                    Тут я, ни в коем случае, не хочу спорить с приверженцами различных парадигм программирования :)
                    Если рассмотреть аспект сложности программного обеспечения с позиции понимания кодовой базы,
                    то мне намного проще живется, зная, что у меня немутабельный стейт и куча чистых функций,
                    через которые проходит большая часть данных моего приложения.

                    Но тут все не так просто, так как Clojure, в первую очередь, разрабатывался как практичный
                    язык программирования. Его нельзя назвать чистым (т.е. есть место для сайд эффектов и взаимодействия с хостом,
                    тут даже Foreign Function Interface не нужен - можно запросто юзать всевозможный JS код, подключать JS либы).
                    Так что чем-то пришлось пожертвовать, и тут уже нам приходится прилагать некоторые усилия для поддержки
                    чистоты)
                </textarea>
            </section>
            <section data-markdown data-separator-notes="^Note:">
                <textarea data-template>
                    ### REPL (Read–eval–print loop)
                    <img src="examples/assets/repl.gif" alt="REPL" width="700">
                    Note:
                    Цикл "чтение - вычисление - вывод".
                    Любой код можно выполнить прямо в редакторе простой комбинацией клавиш.
                    Это упрощает изучение языка, всегда можно, не отходя от кассы, протестировать
                    какой-то метод или кусочек кода за 0 и прочее.
                    Но еще большую пользу REPL приносит в работе: REPL сервер напрямую связан с проектом, таким
                    образом он не только может исполнять куски кода, но и использовать соответствующее состояние моего
                    приложения. Таким образом я могу посмотреть на данные из хранилища, вызвать какой-либо эффект и посмотреть,
                    как поменяется UI в браузере.
                </textarea>
            </section>
            <section>
                <section>
                    <h3>Collections</h3>
                    <div class="columns2">
                        <div class="left-column">
                            All collections in ClojureScript are persistent (immutability + structural sharing).
                        </div>
                        <img src="examples/assets/structural-sharing.png" alt="structural sharing" width="500">
                    </div>
                    <aside class="notes">
                        Персистентная структура данных при внесении каких-либо изменений
                        сохраняет все свои предыдущие состояния и доступ к этим состояниям.
                        Таким образом дорогостоящая иммутабельность реализована в ClojureScript
                        эффективной как по памяти так и по времени. Существует понятие structual sharing, когда
                        большая часть данных "шерится" между 2 версиями значения,
                        а пересоздается лишь маленькая часть действительно изменившихся данных.

                        Аналогично работает ImmutableJS. 
                    </aside>
                </section>
                <section>
                    <h3>List</h3>
                    <p>
                        List provides efficient access to the first elements
                        (linked list under the hood).
                    </p>
                    <pre>
                        <code class="language-clojure" data-trim data-noescape data-line-numbers="1,3-5">
                            (def list' '(1 2 3 4))

                            (let [xs '(1 2 3)     ;; (1 2 3)
                                  ys (cons 0 xs)] ;; (0 1 2 3)
                              (identical? xs (rest ys)))
                            => true
                        </code>
                    </pre>
                    <aside class="notes">
                        Список - эффективный доступ к первому элементу, перебирание элементов, добавление элемента в начало.
                        Аналог связного списка.

                        В основном, списки в ClojureScript используются для группирования символов в программы -
                        вызов функции, например, это тоже список. Для хранения данных обычно используют другие коллекции в отличии от Lisp-а,
                        где все на списках. Такое решение было принятно при разработке языка для упрощения читаемости.

                        Также тут можно посмотреть на пример structural sharing-а. Был создан новый список ys путем добавления нуля в начало списка xs. Но если сравнить xs с
                        rest от ys (хвост списка, все элементы кроме первого), то получится один и тот же список.
                    </aside>
                </section>
                <section>
                    <h3>Vector</h3>
                    <p>
                        Vector provides efficient index access to its elements.
                    </p>
                    <pre>
                        <code class="language-clojure" data-trim data-noescape data-line-numbers="1,3">
                            (def vec' [1 2 3 4])
                        
                            (vec' 0)
                            => 1
                        </code>
                    </pre>
                    <aside class="notes">
                        Вектор - эффективный доступ к элементу по индексу, добавление в конец, Аналог массива.
                        Следует заметить, что ассоциативную структуру данных можно использовать как функцию от ее ключа.
                    </aside>
                </section>
                <section>
                    <h3>Map</h3>
                    <p>
                        Map is a collection abstraction that allows you to store key/value pairs.
                    </p>
                    <pre>
                        <code class="language-clojure" data-trim data-noescape data-line-numbers="1,3,6,9">
                            (def map' {:a 1 :b 2})

                            (get map' :a)
                            => 1

                            (map' :a)
                            => 1

                            (:a map')
                            => 1
                        </code>
                    </pre>
                    <aside class="notes">
                        Map - коллекция, которая позволяет сохранять пары ключ-значение.
                        В других языках это называют хэш-меп или словарь. Любая структура данных может использоваться
                        как ключ мапы, но зачастую используют кейворды - объекты, которые всегда равны сами себе, - из-за
                        того, что они могут быть использованы в качестве функции.
                    </aside>
                </section>
                <section>
                    <h3>Set</h3>
                    <p>
                        Set stores zero or more unique items of any type and is unordered.
                    </p>
                    <pre>
                        <code class="language-clojure" data-trim data-noescape data-line-numbers="1,3,5,8|11,14,17|20,23">
                            (require '[clojure.set :as s])

                            (def set' #{1 2 3 10})
                        
                            (set' 0)
                            => nil

                            (set' 10)
                            => 10

                            (s/union #{0 1 2} #{1 2 3})
                            => #{0 1 2 3}

                            (s/difference #{0 1 2} #{1 2 3})
                            => #{0}

                            (s/intersection #{0 1 2} #{1 2 3})
                            => #{1 2}

                            (s/select odd? #{0 1 2})
                            => #{1}

                            (filter odd? #{0 1 2})
                            => (1)
                        </code>
                    </pre>
                    <aside class="notes">
                        Сет хранит уникальные значения любого типа. Не гарантирует сохранение последовательности.
                        Часто используется как функция-предикат (значение => значение). Появился сет в ClojureScript намного раньше чем в JS и со временем
                        оброс большим количеством функций для работы с ним (в корневой библиотеке).
                    </aside>
                </section>
                <section>
                    <h3>Seq</h3>
                    <pre>
                        <code class="language-clojure" data-trim data-noescape data-line-numbers="1,4,7|10,13,16">
                            (assoc [1 2 3] 0 9)
                            => [9 2 3]

                            (assoc {:a 1 :b 2} :a 9)
                            => {:a 9 :b 2}

                            (conj [1 2 3] 9)
                            => [1 2 3 9]

                            (conj '(1 2 3) 9)
                            => (9 1 2 3)

                            (conj {:a 1 :b 2} [:c 3])
                            => {:a 1 :b 2 :c 3}

                            (conj #{1 2 3} 4)
                            => #{1 2 3 4}
                        </code>
                    </pre>
                    <aside class="notes">
                        Также в ClojureScript есть абстракция Seq (последовательность).
                        Ее можно рассматривать как список и любой другой тип коллекции может быть приведен к последовательности.
                        Большинство внутренних функций ClojureScript работают именно с последовательностями.
                        При вызове они делают последовательности из своих аргументов и работают уже с ними.
                        Таким образом эти функции можно вызывать на любом sequable типе данных.
                        Это также позволяет опускать проверки на пустые коллекции и NIL, поскольку для них
                        будет просто создана пустая последовательность. С помощью этого же маханизма можно довольно просто преобразовывать коллекции
                        из одного вида в другой.

                        И еще одна особенность - большая часть функций возвращает ленивые последовательности, это
                        хорошо сказывается на производительности, но в некоторых местах может поставить в ступор (например,
                        оптимизации реакта могут не работать).
                    </aside>
                </section>
            </section>
            <section>
                <section>
                    <h4>Metaprogramming</h4>
                    <p>
                        Clojure is also a dialect of LISP (LISt Processing language) by design.
                        The aim was to make the language more extensible.
                    </p>
                    <p>
                        Clojurescript allows you to write code that writes code (homoiconicity).
                    </p>
                    <aside class="notes">
                        Как уже было сказано, Clojure - диалект LISP-а. Такое дизайнерское решение было принято для того,
                        чтобы унаследовать от LISP-а способность расширять код. Этому служит система макрокоманд или макросов - по сути, это код, который пишет код.
                        Макрос - функция, которая принимает на вход код (списки) и возвращает код (списки). Макропрограммирование позволяет расширять язык, делать его более выразительным, убирать из кода
                        рутинные шаблоны. Инструмент довольно мощный, но на практике используется не так часто - не стоит переписывать каждый повторяющийся кусок кода на макросы -
                        их сложно дебажить, сложно понять, что и где пошло не так и прочее. Обычно они используются в библиотеках или для оборачивания самих библиотек (в случае JS).

                        Чтобы узнать побольше, можно посмотреть на такое свойство языков программирования как гомоиконичность. 
                    </aside>
                </section>
                <section>
                    <h4>Macros</h4>
                    <pre>
                        <code class="language-clojure" data-trim data-noescape data-line-numbers="1-3,5,8">
                            (defmacro infix
                                [infixed]
                                (list (second infixed) (first infixed) (last infixed)))

                            (+ 1 1)
                            => 2

                            (infix (1 + 1))
                            => 2
                        </code>
                    </pre>
                    <aside class="notes">
                        Здесь изображен очень примитивный пример макроса. В ClojureScript нет операторов, только функции, поэтому для сложения используется префиксная форма.
                        Если слишком уж заскучали за инфиксной формой, то можно написать свой макрос.
                        Как я уже говорил, макросы удобны для оборачивания JS либ. Мы, например, юзаем макросы для styled-components,
                        чтобы шаблонизатор темплейтов из Реакта, понимал, как надо парсить стилизованные компоненты).
                        Также макросы могут быть полезны для упрощения больших кусков кода.
                    </aside>
                </section>
                <section>
                    <h4>Macros for styled components</h4>
                    <p>JS</p>
                    <pre>
                        <code class="language-js" data-trim data-noescape data-line-numbers="1-7,9-11">
                            <script type="text/template">
                                const SubItemNumber = styled.span`
                                    flex: 0 0 ${polished.rem(54)};
                                    margin-left: auto;
                                    text-align: end;
                                    overflow: hidden;
                                    text-overflow: ellipsis;
                                `
                                ...
                                <SubItemNumber>
                                    123
                                </SubItemNumber>
                            </script>
                        </code>
                    </pre>
                </section>
                <section>
                    <h4>Macros for styled components</h4>
                    <p>CLJS</p>
                    <pre>
                        <code class="language-clojure" data-trim data-noescape data-line-numbers="1-7,9,11-14">
                            (defstyled sub-item-number
                                       :span
                                       {:flex (str "0 0 " (polished/rem 54))
                                        :margin-left "auto"
                                        :text-align "end"
                                        :overflow "hidden"
                                        :text-overflow "ellipsis"})
                            ...
                            (sub-item-number "123")
                            ...
                            (js/React.createElement
                                (-> component meta :react-component)
                                #js {}
                                "123")
                        </code>
                    </pre>
                </section>
                <section data-auto-animate>
                    <h4>Threading macros</h4>
                    <p data-id="code-title">Thread-first macro</p>
                    <pre data-id="code-animation">
                        <code class="language-clojure" data-trim data-noescape data-line-numbers="1-2|6-11|17-23">
                            (def user {:first-name "Alex"
                                       :last-name  "Bykbaiev"})
                            => {:first-name "Alex"
                                :last-name "Bykbaiev"}

                            (-> user
                                (update :full-name
                                        #(str (:first-name %)
                                                " "
                                                (:last-name %)))
                                (assoc :mental-age 54))
                            => {:first-name "Alex"
                                :last-name  "Bykbaiev"
                                :full-name  "Alex Bykbaiev"
                                :mental-age 54}

                            (assoc (update user
                                           :full-name
                                           #(str (:first-name %)
                                                 " "
                                                 (:last-name %))))
                                   :mental-age
                                   54)
                        </code>
                    </pre>
                    <aside class="notes">
                        Часто используемые макросы, которые живут в коре языка, - потоковые макросы.
                        Есть несколько разновидностей таких макросов, и мы со всеми познакомимся :troll:
                        Thread-first макрос (извините, не смог перевести) служит для подстановки первого аргумента.
                        Первым аргументом служит результат вызова предыдущей функции.
                    </aside>
                </section>
                <section>
                    <h4>Threading macros</h4>
                    <p>Thread-last macro</p>
                    <pre>
                        <code class="language-clojure" data-trim data-noescape data-line-numbers="1,3,6-9">
                            (def numbers [1 2 3 4 5 6 7 8 9 0])

                            (take 2 (filter odd? (map inc numbers)))
                            => (3 5)

                            (->> numbers
                                 (map inc)
                                 (filter odd?)
                                 (take 2))
                            => (3 5)
                        </code>
                    </pre>
                    <aside class="notes">
                        Thread-last макрос служит для подстановки последнего аргумента.
                        Последним аргументом по аналогии служит результат вызова предыдущей функции.
                        Также тут можно заметить, что вектор numbers стал списком - как правило, функции,
                        у которых коллекция идет первым аргументом, возвращают этот же тип коллекции,
                        а те, где коллекция передается последней, возвращают списки (под капотом все ведь работает на последовательностях,
                        так что проще последовательностями вывод и оставлять, не всегда потребуется приводить ее обратно к вектору, например, поэтому этот шаг опущен).
                    </aside>
                </section>
                <section>
                    <h4>Threading macros</h4>
                    <p>Thread-as macro</p>
                    <pre>
                        <code class="language-clojure" data-trim data-noescape data-line-numbers="1,3,6-10">
                            (def points {:vals [1 2 3 4 5 6 7 8 9 0]})

                            (take 2 (filter odd? (map inc (get points :vals))))
                            => (3 5)

                            (as-> points $
                                  (get $ :vals)
                                  (map inc $)
                                  (filter odd? $)
                                  (take 2 $))
                            => (3 5)
                        </code>
                    </pre>
                    <aside class="notes">
                        Thread-as макрос аналогично служит для подстановки аргумента, но не первого или последнего, а того, что конкретно нужен.
                        Более громоздкая конструкция, но позволяет включать в себя функции, в которых интересующий нас аргумент входит на различных
                        позициях.
                    </aside>
                </section>
                <section>
                    <h4>Threading macros</h4>
                    <p>Thread-some macros</p>
                    <pre>
                        <code class="language-clojure" data-trim data-noescape data-line-numbers="1,3-5,8-10">
                            (def user {:name "Alex"})

                            (-> user
                                (get :mental-age) ;; => nil
                                (str " years"))
                            => " years"

                            (some-> user
                                    (get :mental-age)
                                    (str " years"))
                            => nil
                        </code>
                    </pre>
                    <aside class="notes">
                        2 макроса аналогичных thread-first и thread-last, но в отличии от последних останавливают вычисления на инструкции, которая вернула NIL.
                    </aside>
                </section>
                <section>
                    <h4>Threading macros</h4>
                    <p>Thread-cond macros</p>
                    <pre>
                        <code class="language-clojure" data-trim data-noescape data-line-numbers="1,3,5,7-12">
                            (def month-of-birth "Jan")

                            (def motivating-Mars? true)

                            (def equalizing-Saturn? false)

                            (cond-> []
                                    (= month-of-birth "Jan") (conj "Capricornus")
                                    (= month-of-birth "Feb") (conj "Aquarius")
                                    ;; ...
                                    motivating-Mars? (conj "You would be unstoppable as the moon forms an energetic alignment to driven Mars")
                                    equalizing-Saturn? (conj "Strike a balance between visionary thinking and pragmatic planning"))
                            => ["Capricornus" "You would be unstoppable as the moon forms an energetic alignment to driven Mars"]
                        </code>
                    </pre>
                    <aside class="notes">
                        2 макроса аналогичных thread-first и thread-last, но в отличии от последних могут по условию пропускать некоторые вычисления.
                    </aside>
                </section>
            </section>
            <section>
                <section>
                    <h4>Transducers</h4>
                    <div class="columns2">
                        <div class="left-column">
                            A transducer is a composable higher-order reducer. It takes a reducer as input, and returns another reducer.
                        </div>
                        <img src="/examples/assets/transducer.gif" alt="transducer">
                    </div>
                    <aside class="notes">
                        Трансдьюсер - это огонь! Это функция, которая принимает редьюсер и возвращает редьюсер с дополнительным поведением.
                        Трансдьюсеры знакомы многим, например, операторы RxJS - трансдьюсеры.
                        Их преимущества:
                         - прекрасно работают с композицией функций (их сигнатура позволяет это делать, а сигнатура редьюсера - нет)
                         - могут использоваться для любых перечисляемых типов (массивы, деревья, потоки, графы) - они знают, как обработать элемент и передать его дальше, им нет разницы,
                         частью чего этот элемент является.
                         - все равно, ленивые вычисления или же жадные
                         - эффективные для больших коллекций (или даже бесконечных потоков) - проходят по коллекции лишь единожды независимо от количества
                         операций в пайплайне.
                    </aside>
                </section>
                <section data-auto-animate>
                    <pre data-id="code-animation">
                        <code class="language-clojure" data-trim data-noescape data-line-numbers="1,3-6|11-13,15,18,21">
                            (def xs [1 2 3 4 5 6 7 8 9 0])

                            (->> xs
                                 (map inc)
                                 (filter odd?)
                                 (take 2))
                            => (3 5)

                            ;; map = transform => reducer => reducer

                            (def tr (comp (map inc)
                                          (filter odd?)
                                          (take 2)))

                            (reduce (tr conj) [] xs)
                            => [3 5]

                            (into [] tr xs)
                            => [3 5]

                            (transduce tr conj [] xs)
                            => [3 5]
                        </code>
                    </pre>
                    <aside class="notes">
                        Тут показан пример довольно простого трансдьюсера.
                        Если учесть, что композиция работает справа налево,
                        то сначала может показаться как-будто порядок операций нарушен,
                        нам ведь нужно маппинг, потом фильтрация, потом выбор 2 первых элементов.
                        Но, по сути, все трансдьюсеры, принимая редьюсер, либо вызывают его от обработанных на месте аргументов, либо вообще не вызывают (filter, take).
                        Т.е. порядок меняется автоматически.

                        Многие функции ClojureScript принимают трансдьюсеры.
                        Также можно без проблем писать свои трансдьюсеры, с промежуточным состоянием или без.
                    </aside>
                </section>
                <section>
                    <h4>Transducers</h4>
                    <img src="/examples/assets/transducer-from-the-box.png" alt="ClojureScript functions as transducers" width="800" />
                    <aside class="notes">
                        На прошлом слайде мы использовали map/filter/take, но почему они вообще работают как трансдьюсеры? Это ведь обычные функции для обработки коллекций.
                        Для этих функций под капотом есть 2 версии. Если переданы все аргументы, то это обработчик коллекции, если аргумента коллекции нет, то трансдьюсер
                        (в документации для каждой такой функции есть примечание).
                    </aside>
                </section>
            </section>
            <section>
                <section>
                    <h4>Performance</h4>
                    <img src="examples/assets/compiler.png" alt="compilation flow" width="300">
                    <aside class="notes">
                        Компилятор ClojureScript производит код, совместимый с прогрессивным режимом оптимизирующего компилятора Google Closure. Слишком много компиляторов :D
                        Clojure компилятор - инструмент для оптимизации JS кода за счет полной потери читабельности) Был разработан для Gmail, Google Docs, Google Maps.
                        Легенда гласит, что изначально писали на JS, экономя где только можно, но код выходил абсолютно не читаемым, тогда было решено сделать свой компилятор,
                        а сам код писать красивым и понятным. Также из коробки поддерживается tree-shaking.
                        Все, что требуется от разработчика, для того, чтобы пнуть компилятор - выставить
                        флаг :advanced в конфигурации проекта для production.
                    </aside>
                </section>
                <section>
                    <pre>
                        <code class="language-clojure" data-trim data-noescape data-line-numbers>
                            (def xs [1 2 3 4 5 6 7 8 9 0])

                            (->> xs
                                (map inc)
                                (filter odd?)
                                (take 2))
                        </code>
                    </pre>
                    <pre>
                        <code class="language-js" data-trim data-noescape data-line-numbers>
                            cljs.user.xs = new cljs.core.PersistentVector(
                                null, 10, 5, cljs.core.PersistentVector.EMPTY_NODE, [(1),(2),(3),(4),(5),(6),(7),(8),(9),(0)], null
                            );
                            cljs.core.take.call(
                                null,(2),cljs.core.filter.call(
                                    null,cljs.core.odd_QMARK_,cljs.core.map.call(
                                        null,cljs.core.inc,cljs.user.xs
                                    )
                                )
                            );
                        </code>
                    </pre>
                    <aside class="notes">
                        Тут приведен пример мега простой конструкции и того, как она выглядит после прохода компиляции, но еще до минификации.
                        Получается не особо красиво.
                    </aside>
                </section>
            </section>
            <section>
                <h4>Ecosystem</h4>
                <ul>
                    <li>Leiningen ~ npm (dependencies + scripts)</li>
                    <li>shadow-cljs ~ module bundler</li>
                    <li>Reagent/Om/Rum - React wrappers</li>
                    <li>Re-frame - Redux on steroids</li>
                </ul>
                <div class="columns">
                    <img src="examples/assets/leiningen.png" alt="Leiningen" width="200">
                    <img src="examples/assets/shadow-cljs.png" alt="shadow-cljs" width="200">
                    <img src="examples/assets/reagent.png" alt="reagent" width="200">
                    <img src="examples/assets/re-frame.png" alt="re-frame" width="200">
                </div>
                <aside class="notes">
                    В отличии от JS в ClojureScript намного меньше библиотек.
                    Нужно установить ClojureScript зависимость - берем Leiningen, там же описываем скрипты.
                    Нужен сборщик модулей - берем shadow-cljs (не надо выбирать между webpack, browserify, rollup, parcel и десятком других).
                    Хочешь писать на фреймворке - есть обертки для реакта (на данный момент самая популярная Reagent, есть еще пара штук).
                    Нужен менеджер состояния - берем re-frame (испытал влияние Redux и архитектуры Elm,
                    умеет хендлить сайд эффекты, не надо саги педалить, намного меньше шаблонного кода).
                </aside>
            </section>
            <section>
                <h3>There is always a fly in the ointment</h3>
                <img src="examples/assets/fly-in-ointment.jpeg" alt="cons" width="600">
                <aside class="notes">
                    Поговорим о недостатках. Приходилось выдавливать их из себя, потому что вообще-то ClojureScript топовый)
                </aside>
            </section>
            <section>
                <h4>Bundle size</h4>
                <img src="examples/assets/bundle-size.png" alt="bundle size" width="600">
                <a style="display:block;"
                   href="https://medium.com/dailyjs/a-realworld-comparison-of-front-end-frameworks-2020-4e50655fe4c1"
                   target="_blank">
                    RealWorld Comparison 2020
                </a>
                <aside class="notes">
                    У ClojureScript есть свой runtime, понятное дело, что это добавляет к размеру бандла еще лишние килобайты.
                    Если сравнивать с JS, то это довольно заметно для маленьких проектов, но чем проект больше,
                    тем большим количеством каких-то вспомогательных библиотек он обрастает (lodash, ramda, rxjs etc.).
                    В проектах на ClojureScript библиотек зачастую меньше (язык из коробки предоставляет много возможностей).
                    Плюс к тому эффективный tree-shaking из коробки у shadow-cljs и по исследованию "RealWorld Comparison" бандл среднего
                    по размерам проекта на ClojureScript меньше бандла аналогичного проекта, но написанного на ReactJS.
                </aside>
            </section>
            <section>
                <h4>Performance</h4>
                <img src="examples/assets/performance.jpeg" alt="performance" width="500">
                <aside class="notes">
                    Преобразования данных из CLJS в JS и обратно довольно дорогостоящие.
                    При использовании библиотек из JS это может стать проблемой.
                </aside>
            </section>
            <section>
                <h4>Memory</h4>
                <img src="examples/assets/memory-leaks.png" alt="memory leaks" width="500">
                <aside class="notes">
                    ClojureScript использует довольно много памяти.
                    Обычно это связано с персистентностью коллекций и ленивыми вычислениями
                    (возможно, Garbage Collector не понимает, можно ли удалять данные, которые, по факту, уже не используются -
                    к сожалению, тут я не накопал ничего более конкретного).
                    Ленивые вычисления работают на замыканиях, есть первый элемент и правило, по которому вычисляется следующий,
                    к тому же у ленивых коллекций есть проблема со стек трейсами ошибок - непонятно, когда именно будет вычислен следующий элемент и в каком контексте.
                </aside>
            </section>
            <section>
                <h4>Dynamic type system</h4>
                <img src="examples/assets/dynamic-typing.jpeg" alt="dynamic type system" width="400">
                <aside class="notes">
                    Тут на вкус и цвет товарищей нет. Лично я от ее отсутствия не особо страдаю,
                    да и тот факт, что в рантайме все равно ничего не останется, отталкивает от нее.
                    С Elm-ом и его JSON энкодерами и декодерами работать приятно, с TS-ом просто норм, ни больше ни меньше.
                </aside>
            </section>
            <section>
                <h4>Support</h4>
                <img src="examples/assets/8-years.png" alt="8 years to fix performance issue" width="300">
                <a style="display:block" href="https://www.clojuriststogether.org/" target="_blank">clojurists together</a>
                <aside class="notes">
                    Коммьюнити в ClojureScript несколько меньше чем в JS. Поэтому меньше и библиотек, и активности в них.
                    Но тут все не так однозначно. Существует фонд поддержки разработчиков наиболее важных библиотек на Clojure.
                    Ребята проводят опросы и выясняют, какие библиотеки наиболее полезны, а потом спонсируют их дальнейшую разработку.
                    Также вcе следят за обратной совместимостью, например, текущая версия ClojureScript 1.10.879, аналогично обычно состоит
                    ситуация и для библиотек. Все продумано и стабильно).

                    На скриншоте показан тикет из Clojure, который был открыт 8 лет. Касался производительности одной из кор функций. С ClojureScript ситуация
                    получше (его разработкой занимается отдельная команда), но все же это не JavaScript.
                </aside>
            </section>
            <section>
                <h4>No popular source of knowledge</h4>
                <p>JS - please, read the documentation, there are also learnjavascript, tonns of "Learn JS in 10 mins", video courses, books, blog posts etc.</p>
                <p>ClojureScript - hmm... we have Cheatsheet, maybe some API docs, 2-3 books (it's difficult to find, but you should try!)</p>
                <aside class="notes">
                    Намного меньше учебных материалов по сравнению с более популярными языками делает ClojureScript не то чтобы
                    сложным для изучения, но всегда надо что-то искать)
                </aside>
            </section>
            <section>
                <h4>Job opportunities</h4>
                <p>It's difficult both to find a job and to hire</p>
                <img src="examples/assets/difficult-choice.png" alt="how to get a CLJS job" width="320">
                <aside class="notes">
                    На самом деле, это шутка, есть хорошие компании, в которых используется ClojureScript (например, NuBank - один из крупнейших банков Южной Америки -
                    они выкупили компанию Cognitect, которая занимается разработкой Clojure).
                    А отсутствие популярности вызвано отсутствием маркетинговых компаний, язык то топовый :)
                </aside>
            </section>
            <section>
                <section>
                    <h4>How and why we use ClojureScript in production</h4>
                    <img src="examples/assets/attendify-slide.png" alt="Attendify app" width="800">
                    <aside class="notes">
                        Наш продукт, а рассказывать я буду про продукт Attendify (с ним больше знаком), - комплексная онлайн и мобильная платформа для организации событий,
                        которая также фиксирует вовлеченность пользователей, их цели и предоставляет эти данные для стимуляции роста продукта клиента.
                        Сервер написан на Clojure, фронтенд на ClojureScript.
                    </aside>
                </section>
                <section>
                    <h4>We all write Clojure</h4>
                    <img src="examples/assets/full-stack.jpeg" width="500" alt="full-stack developer">
                    <aside class="notes">
                        Можно переиспользовать код, взять совет у ребят с бекенда, посадить их писать фронтенд :D
                    </aside>
                </section>
                <section>
                    <h4>ClojureScript is an awesome tool to make things fast</h4>
                    <img src="examples/assets/fast.png" width="500" alt="fasten development">
                    <aside class="notes">
                        Разработка на ClojureScript, по моим наблюдениям, идет быстрее чем на JS. Код более лаконичный, много мощных инструментов,
                        которые не надо искать по библиотекам или же писать самому.
                    </aside>
                </section>
                <section>
                    <h4>Performance</h4>
                    <div class="columns2">
                        <div class="left-column">
                            <p class="text-28">Onsite events - up to 10k attendees</p>
                            <p class="text-28">Virtual events - up to 5k attendees</p>
                        </div>
                        <img src="examples/assets/attendify-slide-2.png" alt="Attendify" width="500">
                    </div>
                    <aside class="notes">
                        Приложение поддерживает события вживую и виртуальные. На виртуальных пользователь просматривает видео сессию, на событиях вживую присутствует в зале лично.
                        Все остальное работает аналогично: публикация публичных сообщений, приватное общение в чате, просмотр контента и расписания, голосования, пуш нотификации,
                        закладки, заметки, оценки.

                        Для событий вживую платформа может поддерживать 10к пользователей
                        (после 10к сервис с авторизацией начинал плохо себя чувствовать,
                        но большего и не требовалось - нашей аудиторией не были такие крупные мероприятия).

                        Для виртуальных событий число пользователей в 2 раза меньше - 5к. Тут несколько другие паттерны поведения пользователя -
                        он 100% времени проводит на платформе, нет офлайн активностей (попить кофе, пройти куда-то, перекинуться с кем-то парой слов).
                        К таким изменениям приложение не было готово.

                        Так что проблемы тут не в Clojure, а в решениях, которые были приняты еще в начале разработки продукта, и не позволили должным образом
                        перевести платформу на новые рейки в начале пандемии.
                    </aside>
                </section>
                <section>
                    <h4>Our stack</h4>
                    <p class="text-28">Backend: Ring (HTTP requests), Compojure (routing), Aleph (framework), HugSQL (DB requests), prismatic/schema (declarative data description and validation), custom RPC protocol</p>
                    <p class="text-28">Frontend: Reagent/Rum + re-frame</p>
                    <aside class="notes">
                        RPC - удаленный вызов процедур.
                    </aside>
                </section>
                <section>
                    <h4>How do we live in JS world?</h4>
                    <img src="examples/assets/webpack-module-federation.jpeg" alt="Webpack module federation plugin" width="400">
                    <aside class="notes">
                        Как ClojureScript ведет себя в больших JS приложениях?
                        В данный момент мы работаем над интеграцией ClojureScript приложения как микро-фронтенда. Продукт Hopin построен на микро-фронтендах-фичах,
                        и наш проект с помощью модуля Webpack Federation встраивается в существующую структуру. При этом между микро-фронтендами шарятся общие зависимости.
                        ClojureScript, полет нормальный. 
                    </aside>
                </section>
            </section>
            <section>
                <h4>Some resources to learn more about ClojureScript</h4>
                <ul>
                    <li>ClojureScript Unraveled <a href="http://funcool.github.io/clojurescript-unraveled/#about-this-book" target="_blank">book</a></li>
                    <li>Clojure for the brave and true <a href="https://www.braveclojure.com/clojure-for-the-brave-and-true/" target="_blank">book</a></li>
                    <li>The joy of Clojure <a href="https://www.manning.com/books/the-joy-of-clojure-second-edition" target="_blank">book</a></li>
                    <li>Why I chose ClojureScript over JavaScript <a href="https://m.oursky.com/why-i-chose-clojure-over-javascript-24f045daab7e" target="_blank">post</a></li>
                </ul>
            </section>
            <section>
                <h4>Q&A</h4>
                <img src="examples/assets/q-and-a.jpeg" alt="Q&A" width="600">
            </section>
            <section>
                <h4>Thanks for attention!</h4>
            </section>
        </div>
    </div>

    <script src="dist/reveal.js"></script>
    <script src="plugin/notes/notes.js"></script>
    <script src="plugin/markdown/markdown.js"></script>
    <script src="plugin/highlight/highlight.js"></script>
    <script>
        // More info about initialization & config:
        // - https://revealjs.com/initialization/
        // - https://revealjs.com/config/
        Reveal.initialize({
            hash: true,

            // for PDF printing
            // showNotes: 'separate-page',

            // Learn about plugins: https://revealjs.com/plugins/
            plugins: [RevealMarkdown, RevealHighlight, RevealNotes]
        });
    </script>
</body>

</html>